non-inv: all sent to 1 pt. so going back, 1 pt sent to multiple pts

<<<<<<<<<<<<<<<<<<<<<<
Model 1 to M2:
3 1.3
0.5 2

x = np.array([3, 0.5, 0])  (first col of above mat)
y = np.array([1.3, 2, 0])

Matrix from M1 to M2 (inverse of above):
0.37383177570093457943  -0.24299065420560747663
-0.093457943925233644857    0.56074766355140186916

x times first row of matrix:
0.37 * 3 - 0.24 * 0.5 = 0.99

so x is sent to [1, 0]

x is 'real cat'


4.3
2.5
is sent from M1 to M2 at [1,1]

<<<<<<<<<<<<<<<
Matrix from M1 to M2 (but cleaner values):
0.5 -0.3
-0.1 0.6

Its inverse (first col is where 'real cat' is in M1):
2.2222222222222222222   1.111111111111111111
0.37037037037037037037  1.8518518518518518518

<<<<<<<<<<<<<<<
Further make real cat and fake cat in M1 be more different (not just swapping values of each others' rows, eg. 3 and 2 too close?)

Also, we don't just need real cat and fake cat, but the data sample of cat we calculate to demo MM.

If we let cat demo be: [2, 0.5], we cannot let anything else be close to it. 

Real Cat (sent to 1,0):
[3, 0.5]

An issue w/ what we have is the resulting places where everything is sent in M2 is too small, such as basis vectors.

So we should find regions of 'MUST be fake cat' and regions of 'MUST be real cat' that are not on extremes.

<<<<<<<<<<<<<<<<<<<<<<<
One restriction is the orig basis 1 vecs we chose must be >0, due to being lengths and size (for easier visualization purposes).

But if we allow orig x to be negative, then we can have a rotation

Perhaps negative or positive value (not weight) can mean 'direction'. Such as 'stripes facing left vs right'

<<<<<<<<<
Rotation

Use a negative value to have distance: b/c this is negative y, can be 'tail facing up or down and length from center (flat)'

(cols are where new basis start off from)
2 0.5
-3 1.5

M1 to M2: (where orig basis are sent)
0.33333333333333333334  -0.11111111111111111111
0.66666666666666666666  0.44444444444444444444

<<<<<<<<<
requirements:

- original basis vectors and cat demo vector cannot be sent to somewhere very small (check this in manim)
    thus, values in matrix can't be too small (small decimals)
- new basis vectors cannot start off too close or be very small (inverse of above, check by calculator)
- the values in CoB matrix should not be too small or have too many decimals; they should be intuitive for calculations
- within bounds of manim, vectors cannot go off screen after transformed
    if small and zoomed in, making sure other vecs can still be seen
- new features to use based on CoB matrix must make semantic sense for new basis vecs in M1. (Eg. if use rotation matrix, new basis vecs in M1 would be ni negatives, so feature on that axis where vec is neg must allow for neg interpretation, such as l/r orientation)

not req:
- matrix doesn't need to be orthogonal (cols orth); don't need 90 deg rot, just rot

<<<
M1 to M2:
matrix = [[2, 3], [-1, 1.5]]

ISSUE: inverse is too small. 
B1  B2
1   0.25    -0.5
2   0.16666666666666666666  0.33333333333333333333

Try to take this inverse and make it bigger, then see how that affects M1 to M2?

<<<
2 -1
1.75 0.6

inv:
0.20338983050847457628  0.33898305084745762711
-0.59322033898305084745 0.67796610169491525423

that's bad

<<<
M1 to M2:
2 1
-1 2

inv:
    B1  B2
1   0.4 0.2
2   -0.2    0.4

<<<
actually if you plot out the vectors in:
B1  B2
1   0.25    -0.5
2   0.16666666666666666666  0.33333333333333333333

They're actually far away from each other. 

<<<<
ISSUE: ONE MORE REQ is that new basis vectors should mean 'semantic sense' in that "must be fake" that's sent to (0,1) should mostly have fake cats
    if both pos vals, then they should lie at 'extremes'? no; this is not req, as that means 'very long tail' is always real, etc., making it too easy.

ISSUE: ANOTHER req is to make sure it's not easy to find real/fake just b/c fake is 'always neg'. make sure there are regions where real/fake is blurred and need to use NN to find it.

So w/ a rotation, can values w/ negative x ever be sent to 'real cat' pos values? yes; in b/w the vector of (-0.5, 1/3) and (0.1) are the values that are neg which are rotated to somewhat positive real cat, some which have greater value than fake cat.

<<<<<<
if can't find good neg feature to use, or no semantic sense for (0,1) inv, then stick w/ pos feature, so no rotations.

<<<<<<<
Finally decide to use positive values (face length and body size). This is b/c this easily shows what is grouped as an extreme of 'fake' vs 'real' when above (1,1) and below (1,1) in Model 2. It's also easier to understand the extremes of fake and real mapped to the basis vectors in M2.

In video 3, will use negative values as next example for rotation.

scale this up so 1st basis go to bigger values:
0.5 -0.3
-0.1 0.6

1.5 -1
-0.3 1.8

get its inverse (to find where 2nd basis orig are):
0.75    0.41666666666666666666
0.125   0.625

(this is just the first matrix of the file divided by 3)

Real: [0.75, 0.125]

This is not extreme enough? That's okay. But it's too close to fake.

So there's a trade-off problem with where things orig are and where they go.

<<<<<<<
Actually now that x-axis is nap_happy, and y-axis is ear length, we can do rotation.

M1 to M2:
matrix = [[2, 3], [-1, 1.5]]

ISSUE: inverse is too small (where feat orig are)
B1  B2
1   0.25    -0.5
2   0.16666666666666666666  0.33333333333333333333

<<<<<<<
M1 to M2:
matrix = [[2, 1], [-1, 2]]
2 1
-1 2

inv:
    B1  B2
1   0.4 -0.2
2   0.2 0.4

scale up inv:
1.2 -0.6
0.6 1.2

get: (/ orig by 3)
B1  B2
1   0.66666666666666666667  0.33333333333333333333
2   -0.33333333333333333333 0.66666666666666666666

<<<<<<<
ISSUE: 0.4, 0.2 aren't at extremes. If they were:

M2 to M1:
2 -2
2 0.5

way too small:
1   0.16666666666666666666  0.66666666666666666666
2   -0.66666666666666666666 -0.66666666666666666666

So perhaps it's okay they're not at extremes.

Note that a cat can be BOTH royal and magical, but cats of this certain combo can be neither.

Hard to measure 'happy'. May be easier to measure color?